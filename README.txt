K24: SYSTEM PROGRAMMING  
2η εργασία - Εαρινό εξάμηνο 2020


Ξανθοπούλου Μαρία 
Α.Μ. : 1115201400300


1.  Αρχεία που παραδίδονται

Μέσα στον φάκελο .tar.gz περιέχονται 16 αρχεία ,13 εκ των οποίων αποτελούν τα αρχεία .c και .h , ένα Makefile καθώς και αυτό το README(σε txt και pdf). Επίσης περιέχονται 3 φάκελοι. Ένας άδειος φάκελος output όπου εκεί αποθηκεύονται τα log_files , ο φάκελος του script και ένας φάκελος input ο οποίος έχει φτιαχτεί τρέχοντας το script μου, ο οποίος περιέχει ένα μικρό dataset (δείτε στο 2).


2. Εκτέλεση προγράμματος και create_infiles.sh

Για την εκτέλεση του προγράμματος κάνουμε compile με την εντολη make και έπειτα ακολουθούμε την μορφή:
./diseaseAggregator –w <numWorkers> -b <bufferSize> -i <input_dir>, με τα inputs που επιθυμούμε.
!! Το πρόγραμμα ΔΕΝ τρεχει με μικρό buffersize και με μεγάλο input !!
Έχω συμπεριλάβει έναν δικό μου φάκελο με λίγα inputs ο οποίος έχει φτιαχτεί με το script για τον οποίο το πρόγραμμα τρέχει κανονικά.

Το πρόγραμμα δοκιμάστηκε σε περιβάλλον linux και τρέχει και στα μηχανήματα της σχολής.  Μια ενδεικτική εντολή είναι η:  
./diseaseAggregator -w 10 -b 512 -i ./input 

Για την εκτέλεση του script τρέχουμε την εντολή ./create_infiles.sh diseasesFile countriesFile input 5 5
	

3. Τι υλοποιήθηκε

Από τα ζητούμενα της άσκησης υλοποιήθηκαν οι εντολές: /listCountries, /diseaseFrequency (με και χωρίς παραμέτρους),
 /searchPatientRecord (δεν εκτυπώνει entry και exit date) ,/numPatientAdmissions (με και χωρίς παραμέτρους) , 
/numPatientDischarges (με και χωρίς παραμέτρους) και η /exit.	


ΔΕΝ ΥΛΟΠΟΙΗΘΗΚΑΝ : η εντολή /topk-AgeRanges και οι λειτουργίες με οποιoδήποτε signal.


4.  Δομές / Σχεδιαστικές επιλογές

Οι δομές που υλοποιήθηκαν είναι οι δομές της άσκησης 1. Ο κάθε worker έχει τις δικές του δομές δεδομένων,2 linked lists μια για τις ιώσεις και μια για τις χώρες όπου και στις 2 περιπτώσεις κάθε κόμβος της λίστας θα αποθηκεύσει μια διαφορετική ίωση ή χώρα καθώς και ένα AVL tree για κάθε κόμβο της λίστας.

 
5. Περιγραφή του προγράμματος

Το πρόγραμμα ξεκινάει παίρνοντας απο την γραμμή εντολής τον φάκελο που επιθυμούμε(o φάκελος θα πρέπει να έχει όνομα input), τον αριθμό των worker και το μέγεθος του buffer. Αρχικά το parent process μετράει πόσους φακέλους έχουμε στον φάκελο input. Φτιάχνονται οι διεργασίες και τα named pipes (2 για κάθε worker) και μοιράζει τους φακέλους μέσω named pipe με μέθοδο round robin(Δηλαδή θα ξεκινήσει να μοιράζει ένα ένα φάκελο σε κάθε παιδί και αν έχουν περισσέψει φάκελοι τότε επαναλαμβάνει την διαδικασία για όσες φορές χρειάζεται.
Κάθε worker διαβάζει τους φακέλους και φτιάχνει τις δομές δεδομένων του και στέλνει τα στατιστικά στον πατέρα ο οποίος τα εκτυπωνει.
Τα FIFOS είναι NON-BLOCKING.

Έχω επιλέξει να φτιάχνω ένα struct για κάθε γραμμή που διαβάζεται απο κάποιον worker και να αποθηκεύω σε αυτό τα στοιχεία της. Επίσης έχω δυο linked lists όπου κάθε κόμβος της λίστας είναι και ένας διαφορετικός ιός ή χώρα. Κάθε κόμβος δείχνει σε ένα root ενός AVL tree όπου εκεί αποθηκεύω πάλι pointer , και η ταξινόμιση του δέντρου γίνεται με βάση το processID. Γίνεται έλεχγος για invalid ημερομηνίες και ID κατά την διαδικασία που διαβάζεται το αρχείο.

Έχω επιλέξει τα queries να τα απαντάνε τα παιδιά και να στέλνουν τα αποτελέσματα στον πατέρα(εκτός απο το listCountries και το searchPatientRecord). Το parent process δεν φτιαχνει τις δικές του δομές δεδομένων. Το log_file.xxx φτιάχνεται όταν πάρει το parent process την εντολή exit και αποθηκεύεται στον φάκελο output. Έχω επιλέξει τα succes - fail να τα μετράω ως εξης: Αρχικά κάθε φορά που πληκτρολογούμε μια εντολή αυξάνεται ο συνολικός αριθμός των αιτημάτων. Αν η εντολή είναι έγκυρη αυξάνω τα success αλλιώς τα fail. Όταν στέλνουμε τις εντολές κάθε worker που θα τις διαβάσει αυξάνει ανάλογα τα succes ή τα fail.  

Τέλος γίνονται τα απαραίτητα free για να ελευθερωθεί η δεσμευμένη μνήμη.
